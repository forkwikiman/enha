영어로는 Brute Force, 우리말로는 무차별 대입 공격.

조합 가능한 모든 문자열을 하나씩 대입해 보는 방식으로 암호를 깨는 제일 쉬우면서 무식한 방법. 암호 확인 작업이라는 것이 손으로 입력한
문자열이 기존에 입력된 암호와 동일한지 여부를 체크하는 것이기 때문에, 손으로 입력 가능한 문자열을 하나씩 대입하다 보면 언젠가는 암호를
찾을 수 있게 된다.

예를 들어, 4자리 숫자로 된 핸드폰의 암호는 0000, 0001, 0002... 9999 까지 총 1만개(10^4)의 조합 중 하나이므로,
이를 하나씩 대입해 보면 핸드폰의 암호를 통과할 수 있게 된다. 한번 암호를 입력해 보는데 5초가 걸린다면, 5만초 즉 14시간이면
충분하고, 이를 사람 손이 아닌 컴퓨터로 처리할 수 있다면 1초 이내로 찾아낼 수 있게 되는 것이다.

아래 영상은 [터미네이터2](%ED%84%B0%EB%AF%B8%EB%84%A4%EC%9D%B4%ED%84%B02.md) 에서 [존코너](%EC%A1%B4%20%EC%BD%94%EB%84%88.md) 가 [아타리 포트폴리오](%EC%95%84%ED%83%80%EB%A6%AC%20%ED%8F%AC%ED%8A%B8%ED%8F%B4%EB%A6%AC%EC%98%A4.md)를 이용해서
[ATM](ATM.md) 머신을 해킹하는 장면. (얼핏 보면 브루트 포스처럼 보이지만 화면에 나오는 내용을 보면 진짜 부르트 포스는
아니다.)  

![http://i.imgur.com/GIceyeC.gif](http://i.imgur.com/GIceyeC.gif)

[[GIF external image]](http://i.imgur.com/GIceyeC.gif)

컴퓨터를 잘 모르는 사람들은 브루트 포스 방식을 무식하다고 생각하는 경우가 종종 있는데, 제대로 된 암호화 알고리즘은
[백도어](%EB%B0%B1%EB%8F%84%EC%96%B4.md)라는 게 없기 때문에, 영화나 TV에 나오는 것처럼 뚝딱 하고 암호를
깨는 것은 불가능하다는 것을 이해해야 한다.

예를 들어 예전 [하나 워드](%ED%95%98%EB%82%98%20%EC%9B%8C%EB%93%9C.md) 같은 프로그램은 문서에
암호를 걸어 놓은 후, 문서 파일을 [헥사에디터](%ED%97%A5%EC%82%AC%20%EC%97%90%EB%94%94%ED%84%B0.md)로 열어보면 암호가 문서 파일
헤더에 적혀있는 것을 볼 수 있다. 즉, 문서 파일 자체가 암호화가 된 것이 아니라, 문서에 암호가 걸렸다라는 표시만 해 놓고, 프로그램에서
사용자에게 암호를 물어보아 암호가 동일하면 문서 파일을 보여주는 구조이기 때문에 암호를 아무리 어렵게 저장을 해도 손쉽게 암호를 통과할 수가
있게 되는 것이다.

하지만, 아래한글, MS워드, ZIP 포맷과 같은 파일 포맷은 사용자가 입력한 암호를 통해서 데이터를 암호화 했기 때문에, 암호를 통과하는
방법 따위는 존재하지 않고, 암호를 하나씩 대입해서 데이터를 풀어보는 것 이외에는 우회 방법 따위는 존재하지 않는다.

브루트 포스는 조합 가능한 모든 문자열을 대입하기 때문에 아무리 컴퓨터가 빠르다고 하더라도 시간이 매우 많이 걸린다. 예를 들자면 영문
소문자 + 숫자 조합을 사용할 경우 대입 가능한 문자는 36개 이므로 암호가 1글자 일 경우는 - 36가지 조합 이 되고,  
2글자 = 36^2 = 1296  
3글자 = 36^3 = 46656  
...  
8글자 = 36^8 = 2,821,109,907,456  
...  
10글자 = 36^10 = 3,656,158,440,062,976  
와 같이 기하급수적으로 늘어나게 된다. 쉬운 암호 알고리즘일 경우 현대의 개인용 PC로 초당 1억번 정도 대입해 볼 수 있기 때문에 ((36
^1)+(36^2)+(36^3)+(36^4)+(36^5)+(36^6)+(36^7)+(36^8)+(36^9)+(36^10))/100000000
/86400/365 = 대략 1.1년 정도가 걸리게 되며, 알고리즘이 복잡한 경우는 이보다 수백~수천배 정도 시간이 더 걸리게 된다.

그래서, 암호를 대입할 때 a, b, c, .... aa, ab, ac..... ba, bb, bc, .... 와 같은 모든 가능한 조합을
대입하는 방법 대신 사용자들이 많이 쓰는 암호를 - 예를 들자면 abcd, 1234, qwert, q1w2e3, .... - 모아서 대입하는
방법도 많이 쓰이는데, 이를 사전 공격(Dictionary attack)이라고 한다.

브루트 포스를 이용한 암호 해독과 같은 작업은, 거의 완벽하게 병렬 작업이 가능하기 때문에 [병렬 프로그래밍](%EB%B3%91%EB%A0%AC%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.md)을 사용하거나,
[GPGPU](GPGPU.md)를 이용하기도 하며, 여러 대의 컴퓨터를 연결해서 동시에 암호를 해독할 수 있으며, 이런 방법을 사용하면
돈을 투자하는데 비례해서 암호를 깨는 시간을 줄일 수 있다. 즉, 컴퓨터를 10대 쓰면 10일 걸릴 작업을 1일만에 끝낼 수 있다는 이야기
이다. 얼핏 보면 당연한 듯 보이지만, [암달의법칙](%EC%95%94%EB%8B%AC%EC%9D%98%20%EB%B2%95%EC%B9%99.md) 때문에 이런 식으로 병렬화가 잘
되는 작업은 흔치 않다.

브루트 포스 방식을 이용한 공격은 암호가 걸린 문서나 압축 파일의 암호를 해독하는데도 사용하지만, 온라인 로그인이 필요한 서비스에도 역시
동일한 방식으로 공격할 수 있다. 만일 서버에서 특정 사용자의 ID에 대해서 ID/PW 를 대입하는데 실패 횟수에 대해서 제한을 걸지
않는다면, 병렬로 사용자의 PW를 무차별 대입해서 암호를 알아낼 수 있기 때문에, 제정신을 가진 서버 관리자+프로그래머라면 비 정상적인
로그인 시도에 대해서는 항상 대비를 해야만 한다.  
(간혹 웹페이지를 통한 비정상적인 로그인 시도에 대해서는 차단을 하지만, [POP3](POP3.md)와 같은 눈에 잘 보이지 않는
서비스에 대해서는 비정상적인 로그인 시도를 막지 않아서 사용자 계정이 털리는 경우가 있다.)

다른 사람에게 브루트 포스로 암호가 털리는 것을 원치 않는다면, 다음 사항을 지키자.  

  * 암호는 최소 10자리 이상을 사용하자. 암호가 12자리를 넘어간다면 슈퍼 컴퓨터를 가져와도 안전하다.
  * 암호에 특수문자를 사용하면 좀더 좋겠지만, 특수 문자 안 쓰고 그냥 암호가 길기만 해도 된다. 아무리 특수 문자를 써도 암호가 6자리 이하라면 털릴 것을 각오해야 한다.
  * 웹사이트에 대한 브루트 포스의 경우 대부분 사전 공격부터 가하기 때문에,아무리 비밀번호를 짓기 귀찮더라도 정말 아무나 쓰는 비밀번호는 쓰지 않는 것이 좋다.특히 1234나 abcd,password같은 비밀번호는 사용률이 무척이나 높고 동시에 사전 공격의 최상위에 올려진 경우가 많으므로 피해야 한다.  
  

