  * [프로그래밍 언어/종류](%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4/%EC%A2%85%EB%A5%98.md)  

## Contents

    

1. 개요 
    

1.1. 표준화의 진행

2. 포트란에 대한 오해들 
3. 특징 
    

3.1. 속도논란

3.2. 포트란이 사용되는 예

4. 기타 

[[edit](http://rigvedawiki.net/r1/wiki.php/%ED%8F%AC%ED%8A%B8%EB%9E%80?action=
edit&section=1)]

## 1. 개요 ¶

고대의 [프로그래밍언어](%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4.md).
최초의 고급 언어들 중 하나이다. <del>당신의 지도교수가 옛날에 짠 프로그램을 읽어야 할 경우 배워야 할지도 모르는 언어</del>
[알골](%EC%95%8C%EA%B3%A8.md)과 함께 과학 계산용으로 주로 사용되는 매우 간결하고 엄격한 구문 형식을 가지고 있는
[프로그래밍 언어](%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4.md)이다. 1950년대 말에 [IBM](IBM.md)의 존 배커스(John Backus) 등의 7명의 전문가가 완성한 것이
포트란의 기본이 되며, 그 후 ANSI에서 이를 수정하고 능력을 확장시켜 포트란을 완성시켰다. 하지만 당시 개발된 언어 중에서는 지금도
활발히 쓰이는 언어이기도 하다. 이름의 뜻은 수식 변환기(FORmular TRANslator)의 약자로, 이름 그대로 수식을 계산하는 데
특화되어 있다. 수식 계산에 특화되어 있다는 것은  
1\. 수식을 간단하게 표현할 수 있다.  
2\. 수치 계산이 빠르게 수행된다.  
라는 이념을 가지고 설계되어 있다는 것이다.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%ED%8F%AC%ED%8A%B8%EB%9E%80?action=
edit&section=2)]

### 1.1. 표준화의 진행 ¶

WG5로 불리는 ISO 포트란 위원회에서 ISO표준 논의가 진행되며`[1]` J3로 불리는 US Fortran committee 에서
ANSI 표준이 논의된다. `[2]`

  

대체적으로 ANSI 표준은 거의 변화 없이 ISO 표준으로 받아들여 진다. 현재의 WG5의 구성원은 J3와 대동소이하며, J3는 현재
WG5의 부분으로 활동하고 있다.

  

1956년 개발, 1957년 IBM에서 "THE FORTRAN AUTOMATIC CODING SYSTEM FOR THE IBM 704
EPDM"이란 이름으로 발표한 이후의 약 10여년간은 포트란계의 춘추전국시대였다. 다양한 벤더에서 그들만의 언어적 특징과, 아이디어, 문법을
가지며 이런 저런 포트란을 만들었기 때문이다. FORTRAN II 니 FORTRAN D 니 하는 녀석들도 있었다. 그 시절에도 40여 가지의
컴파일러들이 있었다 한다.

  

1966년에 "Business Equipment Manufacturers Association"의 주도하에 첫 ANSI 표준이 지정되었으며,
이 표준은 36페이지 짜리 문서로 발간되었고 FORTRAN66 또는 FORTRAN IV 라고도 불리며(이는 FORTRAN IV 컴파일러를 그
기반으로 표준화가 진행되었기 때문이다.) 정확한 명칭은 ANSI 3.9-1966이다. 최초의 ANSI표준이 등장하면서 기존의 난해한 상황은
약간 정리가 되었다. FREQUENCY문, SENSE문 같은 여러 벤더에서 자의적으로 사용하던 문법들이 사라지기 시작했기 때문이다. ISO
[R1539:1972는](R1539%3A1972%EB%8A%94.md) FORTRAN66에 대응하는 ISO 표준에 해당한다.(해당
표준의 ISO의 승인은 1972년에 되었다.)

  

이후 가장 널리 알려지고 유명해진 표준은 1978년에 ANSI에 의해 승인된 FORTRAN 77으로 그 문법 만으로도 260여 페이지가
되었다. 현재 대대로 내려오고 있는 많은 수치해석 코드들은 이 표준을 따라 작성된 예가 많다. FORTRAN77은 처음으로 공식적으로
OPEN문, CHARACTER 형 선언이 추가되었다. CHARACTER형이 추가되기 이전엔 각 컴파일러 자의적으로 사용하고 있거나,
Hollerith 수식을 사용했었다.`[3]` `[4]` ISO 1539:1980 이 ISO FORTRAN77에 해당이된다.

  

한편, 미 국방성에서는 이 ANSI FORTRAN 77 에 추가적인 기능이 포함된 표준을 발표한다. `[5]` 이 미국방성 77표준에는
다음과 같은 문법이 적용되었다.  
\- 1. END DO 문  
\- 2. IMPLICIT NONE 문  
\- 3. INCLUDE 문  
\- 4. 정수연산에 대한 비트연산 내장함수 추가  
\- 5. DO WHILE 루프 문  
이 중에서 INCLUDE문을 제외한 문법 사항은 Fortran 90 표준에 공식적으로 포함이 된다. (현재도 INCLUDE문은 표준문법이
아니다.)

  

차기 포트란 표준을 모색하던 포트란 위원회의 구상은 FORTRAN88 이었으나(66,77,88.. 이런 규칙을 가지려고 노력했었던 것 같다)
몇 가지 문법사항이 추가되며 결국 Fortran 90으로 발표된다. ISO/IEC 1539 : 1991 (E) 가 ISO Fortran90의
공식 문서가 된다. 페이지는 388페이지에 달하게 되었다. 이 버전에선 Modern한 언어로서 포트란이 가져야 할 특징들이 대대적으로
정의되었고, 기타 빠르게 변하고 있는 컴퓨팅 업계의 흐름을 따라잡기 위한 시도가 반영되었다. FORTRAN -> Fortran으로 이때
표준의 이름에 소문자가 쓰이기 시작한다.

  

Fortran95는 Fortran90에 추가적인 기능의 필요성이 있어서 발표된 마이너 업데이트다. 병렬컴퓨팅을 지원하기 위한 FORALL문
같은 것(이 문법은 실패한 기능이다.)`[6]`이 추가되었고, 기존의 Non-Modern 한 문법으로 여겨지던 표준이 Obsolescent
에서 Deleted로 바뀜으로, 기존 몇 개의 문법에 대한 삭제가 일어난 표준이다. 포트란 위원회는 이때부터 10년기준의 메이저 업데이트와,
중간 5년단위의 마이너 업데이트를 기획하기 시작한다. `[7]`

  

10년단위 메이저 업데이트로 Fortran2000이 기획되었으나, 역시나 합의가 늦춰지고 Fortran2003으로 발표된다. ISO/IEC
1539-1:2004(E) 가 공식 ISO Fortran 2003의 문서가 된다. 이제 문서의 양은 585페이지로 늘어났다. C언어 바인딩
공식 지원, OOP(Object Oriented Programing), IEEE 부동소수점연산 예외 처리 모듈 지원등을 큰 특징으로 한다.
사실 사용자들이 현실적으로 가장 체감하는 가장 큰 기능은 ISO_C_BINDING 내장 모듈이며, C언어와 Mixing에 대한 방법론을
하나로 통일 시킨 혁신적인 표준이다.

  

Fortran2008은 역시 마이너 업데이트에 해당한다. 기존 Forall 구문이 병렬화를 제대로 지원하지 못했는데, 이는 문법의 제약상
모호한 부분에 의해, 정확한 고려가 없다면 거의 모든 컴파일러에서 그냥 Do Loop를 사용하는 것과 비교해 퍼포먼스상의 이득이 발생하지
않는 형태로 구현되어 버렸다. 이를 보완하기 위해서 Do concurrent를 추가하였고, 95때와 마찬가지로 병렬 프로그래밍에 대한
지원으로 HPF(High performance fortran)프로젝트`[8]` 의 기능들이 대거 추가되었으며, Cray 포트란의 기능이었던
Coarray 기능`[9]`이 추가되었다.

  

차기 포트란 표준은 Fortran2015로 예상되고 있다(기획대로 된 적이 없어서.. 그리 될 지는 알 수 없지만). 메이저 업데이트가
있어야 할 차례이지만, 마이너 업데이트로 기획되고 있다. C언어의 헤더파일을 사용하는 것과 같은 C 바인딩에 대한 확장기능을 제공하는 것을
주요 골자로 한다.

  

현재 대부분의 "컴파일러"는 legacy([하위호환](%ED%95%98%EC%9C%84%20%ED%98%B8%ED%99%98.md))를 기본으로 유지해 주며, 기본적으로 자기들만의
확장기능을 추가적으로 제공한다. 초기 시대에 각 컴파일러마다 제각각 지원하던 기능들을 계속 지원하며, 컴퓨터 환경의 추가적 요구들에 표준보다
먼저 제공하는 것은 컴파일러를 판매하는 상업회사의 기본적 태도이다. 표준은 아니지만 여러 컴파일러에서 비슷하게 지원하는 문법은 특히
사용자에게 착각을 일으키기도 한다. 어떤 회사에서 특징적으로 제공하는 문법이 표준으로 들어갈 수도 있고 아닐 수도 있다. 여러 컴파일러에서
지원하지만, 표준은 아닌 문법/내장프로시저 들이 다수 존재한다. 이것은 본질적으로 각 코드의 이식성의 유지에 어려움을 만들며, 각 컴파일러에
대한 의존성을 낮추기 위해서는 표준에 부합하는 코드를 작성해야한다.

  

표준이 계속 나오면서 obsolescent`[10]`, deleted`[11]`로 구별되는 문법 사항들이 나온다.

  

이하는 90에서 obsolescent로 분류되었던 문법이다.  
1\. Arithmetic IF  
2\. Real and double precision DO control variables and DO loop control
expressions  
3\. Shared DO termination and termination on a statement other than END DO or
CONTINUE statement.  
4\. Branching to an END IF statement from outside its IF block  
5\. Alternate return  
6\. PAUSE statement  
7\. ASSIGN statement and assigned GO TO statements  
8\. Assigned FORMAT specifiers  
9\. H edit descriptor (일명 홀러리스 문자열)

  

90에선 obsolescent로 분류된 항목은 있지만, 77의 문법 중에서 deleted 된 것이 없다. 이후 95에서 이중 6가지가
deleted 되었다. 나머지는 현재의 표준까지도 obsolescent로 목숨을 부지하고 있다.

  

이하는 95에서 삭제(deleted)된 문법이다. 따라서 현재(2008이 가장 최근이며 앞으로 2015가 발표될 것으로 예상되는 시점)는
포트란 표준이 아닌 문법이다.

  

1\. ASSIGN and assigned GO TO statements (할당형 GO TO)  
2\. Assigned FORMAT specifier ( 할당형 FORMAT)  
3\. Branching to an END IF statement from outside its IF block (IF 블록의 외부에서
END IF 문으로 분기)  
4\. H edit descriptor (홀러리스 문자열)  
5\. PAUSE statement (PAUSE를 이용한 멈춤)  
6\. Real and double precision DO control variables and DO loop control
expressions ( DO 루프 제어를 실수형 변수로 하는 것)

  

가장 최근인 2008에서 obsolescent는 다음과 같다.  
1\. Arithmetic IF  
2\. Shared DO termination and termination on a statement other than END DO or
CONTINUE  
3\. Alternate return  
4\. Computed GO TO  
5\. Statement functions  
6\. DATA statements amongst executable statements  
7\. Assumed length character functions  
8\. Fixed form source  
9\. CHARACTER* form of CHARACTER declaration  
10\. ENTRY statements

  

character선언시 * 를 사용하는 것, 고정형식소스 형식 등등이 모두 obsolescent 인 점을 눈여겨 봐야 한다.

  

2008 현재 다음의 추가적 항목의 deleted가 있다.

  

7\. Vertical format control.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%ED%8F%AC%ED%8A%B8%EB%9E%80?action=
edit&section=3)]

## 2. 포트란에 대한 오해들 ¶

다른 언어들 예를 들어 C를 이야기할 때도, 이건 C89야! 이건 C99이야! C11이야! 라고 하지도 않는다. `[12]` 포트란에
대해서만 77, 90을 유독 떠벌리기를 좋아한다. 77, 90 표준을 제대로 구별할 줄 알면서.. 제대로 쓰인 문서가 별로
없다(<del>특히, 한글로 된</del>) 심지어 많은 책들도 그러하지 못하다. 72년에 탄생한 C언어도 여럿 표준을 개정해가고 있고
바뀌어 가고 있음에도, 유독 포트란을 고대어라고 치부하는 치기어린 오해들이 넘친다.

  

1\. Fortran90은 FORTRAN77을 완전히 포함하는 표준이다. (deleted 된 항목이 존재하지 않는다.) 모든 "표준"
FORTRAN77 코드는 완전하게 Fortran90이다. (<del>사람이 동물이듯이</del>) 코드의 "모양"이나 확장자명은 77이니
90이니를 나누는 기준이 아니다.

  

2\. Fixed form이냐 Free form 이냐는 코딩 스타일 문제이다. 물론 77에선 Fixed form 밖에 없다. (90 이후의
기준으로는 그저 선택의 문제이다) 대부분의 컴파일러에서 fixed, free form은 확장자로 체크한다.확장자에 표준의 의미는 담겨있지
않다.

  

3\. 77의 이름을 달고 있는 컴파일러들도 90에서야 표준인 기능들을 다수 "확장 기능"으로 지원한다. 77표준만 딱 지원하는 것이
아니다. 80년대 후반이나 90년대이후 만들어진 77이름을 단 컴파일러들은 대다수가 (END DO, IMPLICIT NONE 문 같은 -
ANSI 표준이 아닌 미국 국방성버전의 확장77부터 추가된 기능. 공식적으론 90이상의 문법으로 불려야 한다.) 이후에 표준화된 문법을
확장기능으로 지원한다. (<del>77이름을 달고 있는 컴파일러로 컴파일 된다고, 모두 77표준은 아니란 소리다</del>)

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%ED%8F%AC%ED%8A%B8%EB%9E%80?action=
edit&section=4)]

## 3. 특징 ¶

포트란의 특징으로는 산술 기호를 그대로 사용할 수 있으며, 삼각함수·지수함수·대수함수 등과 같은 기초적인 수학
[함수](%ED%95%A8%EC%88%98.md)들을 그대로 불러내어 쓸 수 있다는 점이다. 또
[실수](%EC%8B%A4%EC%88%98.md)만이 아니라 [복소수](%EB%B3%B5%EC%86%8C%EC%88%98.md)를
그대로 변수 형으로 쓸 수 있다. 물론 이러한 장점은 현재의 각종 프로그래밍 언어에서는 표준 라이브러리 등을 통해서 기본적으로 제공되는
기능이지만, 당시에는 굉장히 획기적인 방법이었다. <del>이런 걸 초딩들에게 가르쳐준 학원들은 뭐 하자는 거였을까</del> 배열에
대해서도 많이 지원해 줘서, 옛날에 나온 언어임에도 불구하고 Matlab에서처럼 쉽게 배열을 다룰 수 있다.

  

기본적으로 절차적 프로그래밍(procedural programming)이지만 90, 2003을 거치면서 [OOP](OOP.md)의
요소를 많이 넣게 되었다. 하지만 하위호환을 유지해야 하므로 아무래도 C++`[13]`에 비해서는 문법적/구조적으로 불편한 부분이 많다.

  

C와의 큰 차이점 중 하나로 배열의 배치 순서가 서로 다르다. C는 Row-Major Order를 따르며, Fortran은 Column-
Major Order를 따른다. C에서는 (1,1) 다음이 (1,2)이지만, 포트란에서는 (2,1)가 된다. 따라서 다른 언어와 함께
프로그래밍을 할 때는 변수를 넘겨줄 때 순서를 바꾸어 주어야 한다. 또한 반복 계산을 할 때 가장 처음 인수부터 돌려 줘야 성능의 저하가
없다. 또한, 배열의 시작 숫자가 0이 아닌 1부터 시작이다. 사용자가 배열의 인덱스를 조정하는 것이 가능한 것은 포트란의 특징 중
하나이다. 배열의 인덱스를 -100 ~ 100처럼 지정하는 것이 가능하다.

  

초기 버전은 대문자만 인정했기 때문에 가독성이 딸린다. 그 이유는 [키보드](%ED%82%A4%EB%B3%B4%EB%93%9C.md)가
없던 시절 [천공 카드](%EC%B2%9C%EA%B3%B5%20%EC%B9%B4%EB%93%9C.md)로 프로그램을 입력해야 했는데
여기엔 소문자가 없었기 때문.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%ED%8F%AC%ED%8A%B8%EB%9E%80?action=
edit&section=5)]

### 3.1. 속도논란 ¶

[물리학](%EB%AC%BC%EB%A6%AC%ED%95%99.md) 커뮤니티에서 종종 볼수 있는 만년 떡밥. 실재로 Fortran
77의 역량을 맘껏 발휘할 수 있는 알고리즘`[14]`을 돌릴경우 C++의 2배 정도의 속력을 낸다.
[참조](http://www.cs.rpi.edu/~szymansk/OOF90/performance.html) 즉 1달 걸릴 계산이 2주만에
끝난다. 이것이 수치해석에 있어서 포트란을 사용하는것이 항상 좋다는 이야기는 아니지만, 적어도 몇 몇 특수한 알고리즘에 있어서는 포트란을
사용하는 것을 심각하게 고민해 보는 것이 유익하다는 것을 알 수 있다. 물론 복잡한 자료구조를 가진 알고리즘을 짜야 할 경우, 포트란77로
짜다가 돌아버릴지도 모른다.  
포트란은 원래 함수의 [재귀적 호출](recursion.md)을 지원하지 않았다. 재귀함수를 호출하면 그때마다 필요한 오버헤드를
수행해야 하고, [스택](%EC%8A%A4%ED%83%9D.md)에 있는 변수를 참조할 때 한다리 건너 간접적으로 접근해야 하는 등
속도에 불리한 점이 있다. 포트란의 속도가 빠른 이유가 바로 이것. 90 표준에서는 재귀함수를 지원하지만, 사용에 주의를 요한다.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%ED%8F%AC%ED%8A%B8%EB%9E%80?action=
edit&section=6)]

### 3.2. 포트란이 사용되는 예 ¶

80년대 이후로 일반적 목적의 개발에서는 거의 전혀 쓰이지 않는다. 과학기술용 언어로는 포트란, 상업용 언어로는
[코볼](%EC%BD%94%EB%B3%BC.md)이라고 할 만큼 대표적인 제 3세대 언어였지만 1980년대 이후로 보다 사용하기 쉬운
제 4세대 언어의 출현으로 이제는 범용 목적으로는 거의 쓰이지 않게 되었으며, 대부분 [C](C%28%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%29.md) 언어로 교체되었다. 하지만 애당초
수치해석용에 특화시켜 개발되었고, 방대한 [수치해석](%EC%88%98%EC%B9%98%ED%95%B4%EC%84%9D.md)
라이브러리를 가지고 있기 때문에 대량의 계산을 해야 하는 특정 분야에서는 중요한 언어로 명맥을 이어가고 있다. 예를 들어, 수퍼컴퓨터 등의
클러스터를 이용한 대량의 계산을 위한 MPI(Message passing interface)의 경우, 포트란과 C 라이브러리로만 나온다. 즉
수퍼컴퓨터에서는 무조건 C 아니면 포트란을 사용해야 하는 것.

  

[물리학과](%EB%AC%BC%EB%A6%AC%ED%95%99%EA%B3%BC.md)에서 사용하는 예시로는, 다음과 같은 것들이 있다.

  

[원자핵](%EC%9B%90%EC%9E%90%ED%95%B5.md)내 [약력](%EC%95%BD%EB%A0%A5.md)에 의한
핵자간 상호작용을 구하는 것은 굉장한 연산을 필요로 하는데 최대한 효율을 올리기 위해서 포트란으로 프로그래밍을 한다. 다입자계 시간에
의존하는 섭동을 구하려면 수치계산밖에 없는데 막대한 계산에는 시간이 걸리니 거기서 포트란이 다시 등장하는 것이다.

  

양자계산, 흔히 제일원리계산이라고 불리는 분야에서도 포트란으로 짜여져 있는 프로그램들을 많이 볼 수 있다. 이러한 프로그램들은 물질 내부의
원자와 전자 구조를 계산하고 해석할 때 사용되며, 역시 막대한 계산을 효율적으로 수행하기 위해 포트란으로 짜여져 있는 경우가 많다.

  

이처럼 학술 또는 연구 용도의 코드에는 아직까지 포트란이 많이 애용되는데, 여기에는 효율성 측면 이외에도 굳이 다른 언어로 다시 만들 유인이
없다는 사실 또한 작용한다. 연구에 사용되는 코드의 코어 부분은 유서깊고 오래된 것들이 많으며, 어떤 것은 지도 교수의 지도 교수의 지도
교수로부터 내려온 것들도 있다(...). 이러한 코드는 당연히 포트란으로 짜여져 있는데, 이 경우에는 코드가 확장되고 덩치가 커져도 코어와의
호환을 위해 포트란을 사용하는 경우가 많다. 이 경우 잠정적인 사용자는 연구원 내지는 대학원생이 되는데, 이들에게 있어서 문법이 단순한
포트란을 익히는 것은 크게 부담이 되지 않는다. 결국 포트란을 익히면 될 일을 굳이 속도가 더 느린 다른 언어로 옮기는 것 자체가 시간 낭비
인력 낭비가 되는 셈.<del>물론 대학원생이 포트란을 익히는데 드는 수고는 시간 낭비 인력 낭비로 쳐주지 않는다</del>

  

[X-ray](X-ray.md)를 다루는 시뮬레이션에도 사용되는데, PENELOPE라는 Monte-Carlo 시뮬레이터가 이 언어로
짜여져 있다. <del>그런데 2006년 버젼은 버그가 있어서 소스를 살짝 고쳐주는 게 좋다.</del> Monte-Carlo 시뮬레이션이란
Analytic하게 일정 모델을 도입해서 계산하는 게 아니고, 무작정 다수의 입자(이 경우엔 X-ray 광자)를 뿌려서 객체 하나하나당
랜덤하게 경우의 수를 적용해 계산하는 것이라 역시 무지막지한 계산량이 필요하다. 때문에 포트란을 사용한다.
[반도체](%EB%B0%98%EB%8F%84%EC%B2%B4.md) 물성 시뮬레이션을 하는 TCAD도 마찬가지. Stanford 에서
최초로 출하(?)된 PISCES 부터 다 이 언어로 되어 있다.

  

사실 의외로 쓰임새가 많은 언어이나, 일반적으로 보이지 않아서 있는지도 모르는 경우가 많다. 일반 PC에서 사용되는 프로그램의 경우 대부분의
라이브러리가 [C](C.md)나 [자바](%EC%9E%90%EB%B0%94.md) 등의 현용 프로그래밍 언어 기반으로 된 경우가
많으나, 전문분야에서는 매우 많은 계산 알고리즘이 포트란 형식으로 되어 있다. 이들 코드를 다른 언어로 포팅하여 사용하는 것 보다는 포트란을
배워서 쓰는 것이 더 빠르고 계산도 효율적이기 때문에 오래된 [자연과학](%EC%9E%90%EC%97%B0%EA%B3%BC%ED%95%99.md)/[공학](%EA%B3%B5%ED%95%99.md)의 계산 코드는 포트란으로 된 것이 많다. 얼핏 봐서 C로 짰다고 생각되는
프로그램이나 아무리 봐도 비주얼 스튜디오에서 윈도우 기본 함수를 무지막지하게 갖다 쓴 것처럼 보이는 프로그램도 나중에 알고보면 10메가도
안되는 실행파일 하나, 혹은 라이브러리 파일이 핵심 계산 모듈이고 저것은 포트란으로 만든 경우가 많다.

  

가끔 오래된 [팜탑](%ED%8C%9C%ED%83%91.md) PC ([HP](HP.md)의
[200LX](200LX.md)나 [IBM](IBM.md)의 [PC110](PC110.md)같은...)에다가 포트란 컴파일러
깔고 공학용계산기 대신으로 쓰는 [괴인](%EA%B4%B4%EC%9D%B8.md)들도 존재한다.

  

다만 요즘은 대학교에서도 학원에서도 포트란을 가르치는 곳이 거의 없기 때문에`[15]`(심지어 책도 거의 없다) 적어도 한국에서는 잊혀진
언어 취급을 받게될 날이 멀지 않았다.
[데이터베이스](%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4.md) 프로그램이
코볼을 대체했듯이 포트란 역시 대부분의 경우에는 [MATLAB](MATLAB.md),
[매스매티카](%EB%A7%A4%EC%8A%A4%EB%A7%A4%ED%8B%B0%EC%B9%B4.md) 같은 강력한 수치계산
프로그램들에게 자리를 내주고 있다.

  

그러나 이러한 포트란이 매우 주요하게 사용되는 분야가 있으니, 대기과학분야이다. 사실 현재 모든 기상예보는 수치모델을 바탕으로하는데 이
수치모델이 거의 100% 포트란으로 짜여져있다. 앞에서 언급했듯이 굉장한 계산을 해야하기 때문에 다른 언어보다 빠르고 간결한 포트란을 계속
사용해오고 있다(사실 워낙에 포트란으로만 짜둬서 다른 언어로 변환할 수 가 없다). 대기과학이 세계 슈퍼컴퓨터 사용량의 2위를 차지한다는
점을 고려하면 앞으로도 포트란이 잊혀지지는 않을 것 같다.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%ED%8F%AC%ED%8A%B8%EB%9E%80?action=
edit&section=7)]

## 4. 기타 ¶

[전투기](%EC%A0%84%ED%88%AC%EA%B8%B0.md) 소프트웨어로 사용된 전적이 있다.
[F-15S](F-15.md)의 소스코드가 포트란으로 코딩되어있는 것. 이 바닥은 FORTRAN보다 더 원시적(?)인
[어셈블리어](%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC%EC%96%B4.md)를 주로 사용한다. `[16]`

  

한편, 포트란으로 나온 게임도 있다. 세계 최초의 [어드벤쳐게임](%EC%96%B4%EB%93%9C%EB%B2%A4%EC%B3%90%20%EA%B2%8C%EC%9E%84.md)이라고 볼 수 있는
Colossal Cave라는 게임으로, 현재도 소스를 받아서 컴파일해볼 수 있다.

  

재밌게도 띄어쓰기를 무시한다. 그래서 변수 등의 식별자에 공백 문자를 포함해서 써도 된다. CNT X 라고 적어도 잘 동작한다는
소리.`[17]` 반면 줄바꿈은 의미를 가진다.

`\----`

  * `[1]` <http://www.nag.co.uk/sc22wg5>
  * `[2]` <http://www.j3-fortran.org>
  * `[3]` Hollerith - 허먼 홀러리스(Herman Hollerith, 1860년 2월 29일 ~ 1929년 11월 17일)는 독일계 미국인이자 통계학자였다. 그는 수백만 조각의 자료로부터 통계를 빠르게 도표화시키기 위하여 천공 카드를 기반으로 한 공학용 도표 작성기를 개발하였다. 그는 IBM이었던 회사의 창립자이기도 하다. FORMAT 문과 문자열상수에 H표시를 이용한 기법을 홀러리스식으로 부른다. 현재 이 홀러리스 표현은 의미가 없지만.. 아직도 멋 모르고 사용하는 습관을 가지고 있는 사람들이 많이 있고, 그런 오래된 코드들과 정신적 교감을 나누며 코딩 고고학을 지향하는 일들이 벌어지고 있다.
  * `[4]` <http://en.wikipedia.org/wiki/Hollerith_constant>
  * `[5]` <ftp://ftp.nag.co.uk/sc22wg5/ARCHIVE/mil_std_1753.html>
  * `[6]` Fortran2008에 추가된 Do Concurent를 "제대로 된 Forall"로 여기면 된다.
  * `[7]` <http://en.wikipedia.org/wiki/Fortran_95_language_features>
  * `[8]` <http://en.wikipedia.org/wiki/High_Performance_Fortran>
  * `[9]` <http://en.wikipedia.org/wiki/Coarray_Fortran>
  * `[10]` 아직 표준이지만, 앞으로의 표준에서 삭제될 것을 미리 알리는 것. 다른 언어의 deprecated를 의미
  * `[11]` 과거의 표준이었지만, 현재는 지워진 표준
  * `[12]` C의 경우, 상대적으로 표준규격의 변화가 큰 편이 아니며, 최신규격들이 아직 널리 사용되는 편이 아니다. C++/11의 경우 상대적으로 생소한 개념이 많이 추가되었고, 이 규격이 널리 사용되게 되면 C++/11이야! 라는 말도 많이 사용되게 될 것이다. 반면 상대적으로 사용비율은 적을지라도 상용 개발에 많이 사용되는, Basic같은, 언어들은 변종언어들을 만들어내는 방식으로 발전해왔다. 여하튼 표준규격을 논하는 것 자체는 잘못이 아니다. 포트란이 상대적으로 오래된 언어인 것은 사실이며 그 자체가 단점이 되는 것은 아니다. 비웃을 이유도 없고, 비웃음 당한다고 발끈할 이유도 없다.
  * `[13]` 포트란을 많이 사용하는 사용자들에게 대안은 속도 문제로 C나 C++밖에 없다.
  * `[14]` 재귀적 호출을 쓰지 않고 해결할 수 있는 종류
  * `[15]` [서울대학교](%EC%84%9C%EC%9A%B8%EB%8C%80%ED%95%99%EA%B5%90.md) 수리과학부나 통계학과, [연세대학교](%EC%97%B0%EC%84%B8%EB%8C%80%ED%95%99%EA%B5%90.md) 이과대학, [한국항공대학교](%ED%95%9C%EA%B5%AD%ED%95%AD%EA%B3%B5%EB%8C%80%ED%95%99%EA%B5%90.md) 공과대학에서는 아직 가르치고 있다.
  * `[16]` [Ada](Ada.md)도 많이 사용한다
  * `[17]` 덕분에 컴파일러 만들기가 힘들어진다.

