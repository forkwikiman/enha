## Contents

    

1. 개요 
2. 난수 발생 방식 
    

2.1. 선형합동법

2.2. 메르센 트위스터

[[edit](http://rigvedawiki.net/r1/wiki.php/%EB%82%9C%EC%88%98%EC%83%9D%EC%84%B
1?action=edit&section=1)]

## 1. 개요 ¶

컴퓨터는 기본적으로 **난수를 만들수 없다.**

  

그 이유는 컴퓨터는 '계산'을 해서 결과를 내놓지만 계산된 숫자는 난수가 아니기 때문이다. 컴퓨터는 기본적으로 정해진 입력에 따라 정해진
값을 낼뿐이다. 즉, 잘못된 값을 넣으면 이게 이상한줄도 모르고 잘못된 값을 내뱉는다.<del>바보...</del> 전문용어로는 결정적 유한
오토마타(DFA) 기계. 단, 비결정적 유한 오토마타(NFA)인 양자컴퓨터가 실용화된다면 상황은 달라진다. 양자컴퓨터는 기본 알고리즘 자체가
난수에서 시작하기에, 난수생성 따위는 식은 죽 먹기다.

  

이를 해결하기 위해 컴퓨터는 CPU내부에 난수표를 가지고 있으며 이를 이용해서 난수를 생성한다.[#대기 잡음을 이용한 난수표
방식](http://www.random.org)

  

하지만, 여기서 또 한가지 문제가 발생한다. 난수표 자체가 고정된 이상 다음에 다시 난수표를 쓰면 항상 같은 순서로 같은 숫자가 나오게
된다`[1]`. 그 예로 [크레이지 아케이드 테트리스](%ED%81%AC%EB%A0%88%EC%9D%B4%EC%A7%80%20%EC%95%84%EC%BC%80%EC%9D%B4%EB%93%9C%20%ED%85%8C%ED%8A%B8%EB%A6%AC%EC%8A%A4.md)는
난수가 제대로 생성되지 않았던 탓에 [테트리스](%ED%85%8C%ED%8A%B8%EB%A6%AC%EC%8A%A4.md) 계의
[쿠소게](%EC%BF%A0%EC%86%8C%EA%B2%8C.md)로 전락할 뻔했다.

  

이를 해결하기 위한 방법은 난수표를 여러개 만들어 놓고 매번 다른 난수표를 읽도록 만드는 것이다. 이 난수표를 선택하는 것을
[시드](%EC%8B%9C%EB%93%9C.md)라고 한다. 그런데 시드값이 똑같으면 수열이 나오는 순서도 똑같기 때문에 시드값도
난수여야 한다. 즉 **난수를 만들려면 난수가 필요하다**는 [모순](%EB%AA%A8%EC%88%9C.md)이 발생하게 되는 것.
그래서 보통은 시드값으로 현재 [시간](%EC%8B%9C%EA%B0%84.md)을 넣어서 해결한다. 일반적으론 밀리초, 즉
1/1000초 단위의 값이니 인간 레벨에서는 의도적으로 같은 값을 내게 하는건 불가능에 가깝다. 단, 모두 밀리초를 쓰는 건 아니고 기기의
내장 시계에 따라 달라질 수 있다. 예를 들면 1프레임(1/60)을 찾아 조작하는 [에메랄드루프](%EC%97%90%EB%A9%94%EB%9E%84%EB%93%9C%20%EB%A3%A8%ED%94%84.md)같은 것.

  

여담으로 사람이나 기계로 직접 숫자 등을 뽑는 형태가 아닌 경우, 컴퓨터는 사람처럼 무의식적인 선택, 혹은 우연에 의한 선택을 할 수
없으므로 특정한 난수 생성 수식을 통해 임의의 값을 만들어 내는 것이다. 따라서 랜덤은 단어 뜻대로인 임의의 값이 아니고 특정한 수식으로
계산하여 임의의 값인 것처럼 보이게 하는 것이다.

  

그러나, 함수에 대해 수만번 통계를 내어보았을 때 각 경우의 수가 거의 모두 같은 경우만을 랜덤 함수로 취하므로 사실상 랜덤이라고 봐도
무방하다.

  

그런데 여기서, 랜덤을 구하는 방법은 수식이기에 **seed값(종자값)**이라고 하는, 난수발생수식의 초기해에 영향을 주는 요소가 같은
경우(미리 정해주지 않은 경우), 수만 번을 랜덤을 돌려도 결과는 항상 똑같은 패턴이 나오게 된다.`[2]` [에메랄드루프](%EC%97%90%EB%A9%94%EB%9E%84%EB%93%9C%20%EB%A3%A8%ED%94%84.md)도 이러한 이유
때문에 발생한다.

  

따라서 보통은 프로그램을 짤 때 seed값이 '현재의 시간'에 영향을 받게 함으로서 영향을 주는 값들을 임의의 값으로 느끼게 하도록 보정하게
된다.

  

하지만 근본적으로 시드를 기반으로 한 랜덤함수는 확률에 있어서 완전히 무작위라고 보기가 힘들다. 물론 일반적인 게임에서는 시드값만 바꿔주면
충분히 무작위처럼 보이는 효과를 낼 수 있으나 어쨌거나 32비트 기반이라면 시드의 개수자체가 2의 32승이고 즉 패턴의 수도 딱 그만큼이다.
대충 사십억이 넘는 값인데, 물론 충분히 많아 보이지만 이게 무한은 아니라는게 문제. 특정 패턴의 경우 영원히 안나올 수도 있다. 예를 들어
현찰이 오가는 도박 사이트의 경우 시드 기반의 의사랜덤은 쓰질 않는다. 참고로 [여기](http://www.random.org/)가 진정한
랜덤 숫자를 제공하는 곳인데 무슨 대기 소음을 측정해서 뭐 어쩐다고 한다. 사실 정확히 말하면 이것은 진정한 랜덤이 아니다. 대기 소음이
정확히 같다면, 즉 인풋이 같다면 나오는 랜덤값도 동일하기 때문. 진정한 랜덤으로 양자역학을 사용하는 경우가 있는데, 동일한 확률을 만들어
놓고 관측하여 한 가지의 가능성만 남기고 모두 붕괴시키는 방법이다. USB형 양자원리 기반 난수생성기도 있는듯.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%EB%82%9C%EC%88%98%EC%83%9D%EC%84%B
1?action=edit&section=2)]

## 2. 난수 발생 방식 ¶

난수를 발생시키는 수식엔 여러가지가 있는데, **중앙 제곱법**과 **합동식 방법** 등이 있다.  
난수발생원리에 대해 자세히 알고싶으면
[여기](http://en.wikipedia.org/wiki/Random_number_generation)를 참고.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%EB%82%9C%EC%88%98%EC%83%9D%EC%84%B
1?action=edit&section=3)]

### 2.1. 선형합동법 ¶

가장 널리 쓰이는 유사난수법.  
계산이 매우 빠르기 때문에 초창기부터 컴퓨터에 널리 사용되었으며, 흔히 쓰이는 rand() 함수는 바로 이것이다. 난수분포가 치우쳐 있고,
주기성이 있다는 결점이 있지만 계산속도가 빠르기 때문에 지금도 난수의 품질을 크게 신경쓰지 않는 경우에는 널리 사용된다. 그런데 시드가
같으면 의미도 없기에 보통은 srand(time(0))으로 난수를 초기화한다. 요즘에는 이 과정을 객체 차원에서 수행하는 모듈도 많이 나와
있다.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%EB%82%9C%EC%88%98%EC%83%9D%EC%84%B
1?action=edit&section=4)]

### 2.2. 메르센 트위스터 ¶

흔히 mt_rand()라는 이름을 가진다. 선형합동법보다 품질이 좋은 난수를 뽑아준다.

`\----`

  * `[1]` 패미컴 버전 봄버맨에서 맨 처음 플레이할 때 1탄의 벽돌들이 대체로 일정하게 배열된다는 점을 떠올리면 어느 정도 이해가 갈 것이다.
  * `[2]` 복잡한건 넘어가고 중학교때 배운 함수의 기초에 대해 생각해보자. 하나의 값을 넣으면 대응하는 하나의 값이 나와야 한다. 즉, 수식에 같은 값을 집어넣으면 같은 결과가 나올 수 밖에 없다.

