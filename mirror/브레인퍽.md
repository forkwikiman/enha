Brain[Fuck](Fuck.md)  
현존하는 [난해한 프로그래밍 언어](%EB%82%9C%ED%95%B4%ED%95%9C%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4.md)의 최고봉.  
1993년 우어반 뮐러가 제작했으며 제작된 파일 [확장자](%ED%99%95%EC%9E%A5%EC%9E%90.md)는 .b, .bf

최고봉이라고 실망하지만은 말자. 노력하면 배울 수는 있다. <del>근데 몇분 후에는 때려 칠 수도 있다</del>

개발 목적은 가장 작은 컴파일러로 구현할 수 있는 튜링 완전`[1]` [프로그래밍언어](%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4.md)를
만드는 것이었다고 한다. **세상에서 가장 단순하면서 복잡한 언어**라는 말이 어울리는 언어로, 프로그래밍에 사용되는 문자는
**+-[]><,.** 로 딱 8개다.

참고로 이름인 브레인[퍽](%ED%8D%BD.md)의 퍽은... 이 글을 보는 사람들이 생각하는 그 퍽이 맞다. Brainfuck이다.
말 그대로 [뇌](%EB%87%8C.md)를 엿먹이려고 만든 [변태](%EB%B3%80%ED%83%9C.md) 프로그래밍 언어다.
그래서 욕필터에 걸리는 경우가 있기 때문에 Brainf*** , 또는 약자만 따서 B.F. <del>[대검](%EB%A6%AC%EA%B7%B8%20%EC%98%A4%EB%B8%8C%20%EB%A0%88%EC%A0%84%EB%93%9C#s-1.12.md)</del>등 으로
부르는 경우가 많다고 한다.

프로그래밍 방법은 엄청나게 난해하지만, 일단 튜링 완전 타입의 언어이기 때문에 이론적으로는 컴퓨터가 할 수 있는 모든 일을 다 할 수 있다.
그리고 컴퓨터의 연산이 작동하는 방법을 이해하고 있다면, "배우는"것은 매우 쉽고 단순하다. 실제로 사용하기가 매우 난해한게 문제다. 일단은
일반적인 난해한 프로그래밍 언어들이 다 그렇듯이 포인터를 기본으로 한 명령 체계를 사용하고 있으며 명령어들 역시 포인터를 옮기는 명령어들로
구성되어 있다.

명령어를 살펴보면

  * > : 포인터 증가
  * < : 포인터 감소
  * \+ : 포인터가 가리키는 바이트의 값을 증가
  * \- : 포인터가 가리키는 바이트의 값을 감소
  * . : 포인터가 가리키는 바이트 값을 아스키 코드 문자로 출력한다
  * , : 포인터가 가리키는 바이트에 아스키 코드 값을 입력한다
  * `[` : 포인터가 가리키는 바이트의 값이 0이 되면 ]로 이동한다
  * `]` : 포인터가 가리키는 바이트의 값이 0이 아니면 [로 이동한다  

이외의 공백, 엔터, 기타 문자등은 모두 처리되지 않는다.  
다음은 브레인퍽으로 만들어진 [Hello, world!](Hello%2C%20world%21.md)의 예제

**`++++++++++``[>+++++++>++++++++++>+++>+<<<<-]``>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.`**

무슨 말인지 알 수 없다고 생각하는게 **당연하다.** [포인터](%ED%8F%AC%EC%9D%B8%ED%84%B0.md)와 코드,
메모리 구조에 대한 기본적인 지식은 있어야 아래 설명을 이해할 수 있다. 굳이 위 프로그램이 어떻게 동작하여 Hello,World 를
출력하는지 알아보면,

**1\. ++++++++++**  

첫 번째 포인터가 가리키는 주소의 값을 10 증가시켰다. 초기값은 0 이므로, 포인터가 가리키는 값에 10이 들어간다.

**2\. [>+++++++>++++++++++>+++>+<<<< **  

두 번째 부터 다섯 번째 포인터가 가리키는 주소의 값을 각각 7 , 10 , 3 , 1 씩 증가시킨다. 증가시킨 후 다시 원래의 첫 번째
포인터를 가리키게 한다.

**3\. -] **  

첫 번째 포인터 값을 1 감소시킨후, 그 값이 0이 아닐 경우 2. 의 [ 로 돌아간다. 즉 10번짜리 루프문이 되며, 2~5번째 포인터에는
각각 70 , 100 , 30 , 10 의 값이 들어가게 된다.

**4\. >++. **  

두 번째 포인터가 가리키는 값에 2를 더한 후 그 값을 아스키코드로 출력한다. 두 번째 포인터의 값은 70이며, 2를 더하면 72가 되고
이것에 대응되는 아스키코드 문자는 H 이다.

**5\. >+.+++++++..+++.**  

세 번째 포인터 에 1을 더한 후 한 번 출력, 또다시 7을 더한 후 두 번 출력, 또다시 3을 더한후 한 번 출력한다. 세 번째 포인터값은
100 이었으므로, 각각 101, 108, 108, 111에 대응하는 아스키코드 문자열이 출력되며, 이것은 'ello' 가 된다.

**6\. >++.<<+++++++++++++++.>.+++.----<del>.</del>\------.>+.>.**  

4~5와 같다. 포인터에 저장되어 있는 값에 숫자를 빼고 더해 가면서 문자를 출력한다. 여기서 ',World!' 가 출력되는 것.  

놀랍게도 업그레이드(?) 버전으로 2개의 포인터를 쓰는 더블퍽(Doublefuck)이라는 놈이 존재하며, 같은 원리의 프로그래밍 언어로
[Ook!](Ook%21.md)가 존재한다. Ook!는 브레인퍽과 명령체계가 완전히 똑같아서 브레인퍽<->Ook! 컨버전 프로그램도
존재한다.

이외에도 많은 브레인퍽 기반의 esolang이 존재한다. 상세는 난해한 프로그래밍 언어 문서의 [Misa](%EB%AF%B8%EC%82%AC%EC%BF%A0%EB%9D%BC%20%EB%82%9C%EC%BD%94%EC%B8%A0.md) 및 [Nyaruko](%EA%B8%B0%EC%96%B4%EC%99%80%EB%9D%BC%21%20%EB%83%90%EB%A3%A8%EC%BD%94%EC%96%91.md)
참조. 그외에도 일본에는 [죠죠러](%EC%A3%A0%EC%A3%A0%EB%9F%AC.md)를 위한 해당 언어 기반의 esolang까지
[존재](http://d.hatena.ne.jp/toyoshi/20100208/1265587511)한다(...)

여담이지만 [SeeU](SeeU.md)의 [반도의 흔한 이별노래](%EB%B0%98%EB%8F%84%EC%9D%98%20%ED%9D%94%ED%95%9C%20%EC%9D%B4%EB%B3%84%EB%85%B8%EB%9E%98.md)에서 브레인퍽을 소재로 사용하였다.

코드를 직접 실행해 보고 싶으면 [여기로](http://esoteric.sange.fi/brainfuck/impl/interp/i.html)

`\----`

  * `[1]` 어떤 프로그래밍 언어나 추상 기계가 튜링 기계와 동일한 계산 능력을 가진다는 뜻이다. 튜링 기계는 계산 가능한 모든 함수를 계산할 수 있는 추상적 모델을 말하는데, 쉽게 말해서 이상적인 [컴퓨터](%EC%BB%B4%ED%93%A8%ED%84%B0.md)를 생각하면 된다. 한 가지 태클이 걸릴 점은, 현실 역사에선 튜링 기계란 개념이 나온 뒤에 그 개념에 기초해서 컴퓨터가 나왔다는 것.

