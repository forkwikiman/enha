[슈퍼스칼라](%EC%8A%88%ED%8D%BC%EC%8A%A4%EC%B9%BC%EB%9D%BC.md) 기술과 함께
[CPU](CPU.md)의 속도를 향상시키기 위한 회로 내지는 회로설계 기법을 지칭한다.

[[edit](http://rigvedawiki.net/r1/wiki.php/%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%B
C%EC%9D%B8%28CPU%29?action=edit&section=1)]

## 개요 ¶

CPU의 회로는 스위치 역할을 하는 많은 수의 트랜지스터`[1]`가 연결된 회로로 구성되며 이 회로들은 시스템 클럭에 의해 동기화되어
동작된다. 즉 시스템 클럭이 일정 횟수가 입력될 동안 트랜지스터 회로들은 소정의 처리작업을 완료하고 다음 처리동작이 가능한 상태가 되어야
한다. 이 과정에서 주의해야 할 요소는 다음과 같다.  

  * 트랜지스터 자체의 스위칭 속도는 무한하지 않으며 물리적 한계가 존재한다. 이 한계를 예를 들어 100MHz라고 가정하자.
  * CPU회로에서 트랜지스터들의 동작이 시작되는 위치에서부터 동작이 종료되는 위치까지 직렬 연결된 최대 단계가 100단계라고 가정한다.
  * 그럴 경우 예로 든 CPU회로는 각 트랜지스터의 동작속도가 100MHz라고 해도 전체 회로의 동기화는 직렬연결된 최대 길이 100단계의 제약을 받기 때문에 회로에 입력할 수 있는 최대 클럭은 100MHz/100 = 1MHz가 된다.  

그리고 어느 날 어떤 공돌이가 이런 멋진 생각을 하게 되었다.

  

"중간 중간에 동작 상태를 저장해 놓고 다음 클럭이 들어왔을 대 그 상태를 다음 단계로 넘겨주면 직렬연결 단계를 줄이게 되면서 동작클럭을
높일 수 있지 않을까?"

  

CPU회로에서의 파이프라인이라는 개념이 탄생하는 순간이었다.

  

즉 중간에 동작 상태 저장 단계를 5개 추가했다고 가정하면 같은 100MHz짜리 트랜지스터라고 해도 직렬연결의 단계는 100단계에서 최대
20단계로 줄어들게 되고 해당 CPU 회로가 수용할 수 있는 클럭은 100MHz/20stage=5MHz까지 증가하는 것이었다.

  

파이프라인에 대한 전통적인 설명은 4단 파이프라인 구조를 통한 것이며 대체로 다음과 같은 명칭을 가지고 있다.

  

1단계 : fetch(명령어를 메모리에서 인출)  
2단계 : decode(명령어 해석)  
3단계 : execute(명령어 실행)  
4단계 : writeback(라이트백)  

[[edit](http://rigvedawiki.net/r1/wiki.php/%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%B
C%EC%9D%B8%28CPU%29?action=edit&section=2)]

## 역사 ¶

파이프라인이라는 개념이 단일칩 CPU에 도입된 것은 최소한 80년대 초 [RISC](RISC.md)의 태동과 궤적을 같이 했을 것으로
추정된다. 이후 파이프라인 단계의 확장 역사는 다음과 같다.

  

x86

  * 1986년 i80386 : 2단계
  * 1989년 i80486 : 5단계
  * 1993년 P5 : 5단계
  * 1997년 P6 : 10단계
  * 2001년 윌라멧 : 28단계
  * 2004년 프레스캇 : 39단계
  * 2006년 Core : 14단계

[[edit](http://rigvedawiki.net/r1/wiki.php/%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%B
C%EC%9D%B8%28CPU%29?action=edit&section=3)]

## 한계 ¶

파이프라인 기법이 가지는 한계는 다음과 같다.  

  * 프로그램 구조가 명령어를 순차적으로 일정하게 실행하도록 되어있을 때 최적의 효율을 낼 수 있는 파이프라인 구조이지만 현실의 프로그램은 순차적이지도 않으며 일정하지도 않다. 즉 파이프라인 구조가 작동하는 도중 메모리지연, 예측에 실패한 분기명령, 전후로 의존적인 명령어와 데이터를 만나게 되면 파이프라인의 작동이 중단되거나 최악의 경우 그동안 처리중이었던 명령어들을 모두 버리고 다시 처리해야 하는 경우가 빈번하게 발생하였다.
  * 바로 위에서 언급한 파이프라인의 문제점들을 해결하고자 명령어/데이터 선인출, 투기적실행, 분기예측, 레지스터 리네이밍, 명령어 프리디코드 등의 여러 기법들이 개발되고 적용되어 파이프라인의 문제점들을 상당히 완화하는데에는 성공하였으나 그러한 추가 기능들의 도입을 위해 대량의 트랜지스터가 추가로 투입되었으며 결국 CPU의 구조가 매우 복잡해지는 결과를 낳았다.
  * 파이프라인 단수의 증가를 통해 클럭을 올리는 전략은 또다른 제약사항이었던 발열 문제로 인해 결국 2004년경 [4GHz의 벽](4GHz%EC%9D%98%20%EB%B2%BD.md)에 가로막히면서 중단되었다. 그 이후로는 다시 31단계에 이르는 깊은 파이프라인을 시도하지 않게 되었다.  
  

[[edit](http://rigvedawiki.net/r1/wiki.php/%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%B
C%EC%9D%B8%28CPU%29?action=edit&section=4)]

## 의의 ¶

현대의 CPU 중에서 어느 정도 성능을 지향하도록 개발된 CPU 중 파이프라인 구조를 채택하지 않은 CPU는 사실상 없으며 특히 적극적인
파이프라인의 도입은 80년대말~2000년대 초에 경험했던 급격한 CPU클럭의 향상과 그로 인한 CPU 성능 향상에 지대한 공헌을 하였다.
비록 2004년도 31단계라는 무지막지한 파이프라인 구조를 끝으로 파이프라인 단계 확대의 움직임은 제동이 걸린 상황이지만 그 이후의 CPU들
조차도 파이프라인 구조 없는 설계는 생각하기도 힘든 게 오늘의 현실이다.

`\----`

  * `[1]` 게이트라는 표현도 쓴다. 현용 대부분의 CPU의 집적회로가 CMOS기술로 구현되며 CMOS의 트랜지스터의 가운데 극의 이름이 게이트이기 때문

