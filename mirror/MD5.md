> 'RigVeda Wiki'를 MD5변환한 결과 : A2625540BD3D38019AD6C68CBD0C659D

Message-Digest algorithm 5

임의의 길이의 값을 입력받아서 128비트 길이의 [해시값](%ED%95%B4%EC%89%AC.md)을 출력하는
[알고리즘](%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.md)이다.
[1991년](1991%EB%85%84.md) 설계되었다.

MD5는 단방향 암호화이기 때문에 출력값에서 입력값을 복원하는 것은 할 수 없다. 같은 입력값이면 항상 같은 출력값이 나오고, 서로 다른
입력값에서 같은 출력값이 나올 확률은 극히 낮다(0은 아니며 발생할 수 있다.).

흔히 [패스워드](%EB%B9%84%EB%B0%80%EB%B2%88%ED%98%B8.md) 암호화에 많이 사용되는데, 패스워드를
MD5로 해쉬해서 나온 값을 저장해 두는 것이다. 이렇게 하면 운영자나, 데이터를 무단으로 뜯어본 자도 이 값만 봐서는 본래의 값 자체는 알
수 없게 된다. 비밀번호를 정확하게 입력했다면 같은 해쉬값이 튀어나오므로, 본래의 키라는 것을 확인할 수는 있는 것이다.

단방향 암호화이기 때문에 MD5 해시값에서 원래의 데이터를 찾아내는것은 불가능하며(원문을 해시 계산 과정에서 **비트 단위로
[개발살](%EA%B0%9C%EB%B0%9C%EC%82%B4.md)내버린다**),
[크래커](%ED%81%AC%EB%9E%98%EC%BB%A4.md)들은 "같은 MD5를 갖는 문자열", 즉
"충돌"(Collision)을 찾아내는데 주력한다. 어쨌든 MD5값이 같으면 같은 문자열이라고 판단하기 때문이며 이는 모든 단방향 암호화에
통용되는 기법이다`[1]`.

2004년에 [높은 유사성을 보이는(하지만 엄연히 다른) 128바이트 파일 두 개의 해쉬 값 충돌이
발견되었다.](http://eprint.iacr.org/2004/199) 이는 알고리즘 자체의 엄청난 결함이다. 논문에 따르면 IBM
P690 머신에서 충돌을 생성하는데 한 시간밖에 걸리지 않았다고 한다.

2006년에는 [더욱 빠른 알고리즘이 개발되어 논문에 따르면 노트북 한 대의 연산 능력 (Intel Pentium, 1.6 GHz)으로 1분
만에 충돌을 찾아낼 수 있다고 한다.](http://eprint.iacr.org/2006/105) 그래서 보안이 중요시되는 해시 연산은
[SHA](SHA.md) 계열 해시 함수로 대체되고 있다.

심지어는 [다른 결과가 나오는 프로그램이 같은 MD5 값을 가질 수도 있다.
](http://www.mscs.dal.ca/~selinger/md5collision/)

다만 고속 연산이 가능하고(정수 연산 및 비트시프트로 모든게 해결된다.) 임의로 변경된 패턴에 대해서는 충돌 가능성이 충분히 낮기 때문에,
현재는 주로 네트워크로 전송된 큰 파일의 무결성을 확인하는데 주로 사용된다. 보안용도로 쓸 때는 꼭 salt를 붙여서 쓰는게 안전하지만 다른
알고리즘을 권장한다.

특히, 앞에서 언급된 네트워크에서는 OSI 7계층 중 2계층에 속하게되는 장비인 Switch, 3계층에 속하게되는 Router는 장비간의
상호인증체계로 활용된다. (Cisco IOS 기준)

[[edit](http://rigvedawiki.net/r1/wiki.php/MD5?action=edit&section=1)]

## 관련항목 ¶

  * [비밀번호](%EB%B9%84%EB%B0%80%EB%B2%88%ED%98%B8.md)
  * [암호](%EC%95%94%ED%98%B8.md)
  * [해쉬](%ED%95%B4%EC%89%AC.md)
  * [MD5 배틀](MD5%20%EB%B0%B0%ED%8B%80.md)
  * [SHA](SHA.md)

`\----`

  * `[1]` 1234나 love 등의 간단한 숫자나 단어만 써서 암호를 만들지 말라는 이유는 여기서도 통용된다. 이런 간단한 암호는 해커들이 가지고 있는 해시값 사전에도 있을 확률이 거의 100%이기 때문이다.

