CUDA(Compute Unified Device Architecture). 보통 쿠다라고 읽는다.

[nVIDIA](nVIDIA.md) 그래픽 카드에서 작동하는 범용 병렬 컴퓨팅 아키텍처로써 C 언어와 비슷한 문법의 언어로 GPU가
일반적인 병렬 연산을 수행하게 해 준다. 모든 nVIDIA 그래픽 카드에서 작동하는 것은 아니지만 아주 오래 된 기종이 아닌 한(8
시리즈부터) CUDA 사용에 무리가 없다. nVIDIA에서는 아예 CUDA를 사용하기 위한 연산 전용 그래픽 카드를 Tesla`[1]`라는
이름으로 출시했다.

그래픽 카드의 GPU는 대량의 데이터에 한 가지 연산을 적용하는 경우가 많기 때문에 단순화된 연산 유닛(코어)을 천여 개씩 탑재하고
있다.`[2]` 따라서 [SIMD](SIMD.md)(Single Instruction Multiple Data) 형태의 병렬화가 가능한
연산에 GPU를 활용해서 속도를 올리려는 시도는 예전부터 있어 왔다. 그러나 원래 그래픽을 처리하라고 설계된 그래픽스 파이프라인을 가지고
일반적인 병렬 연산을 수행하는 것은 매우 골치아픈 일이었다. 프로그래머가 일일히 GPU의 세부 사항을 다 신경써야 했기 때문이다.

CUDA는 GPU의 메모리 모델을 추상화해서 좀 더 편하게 GPU을 이용할 수 있도록 했다. 하지만 여전히 CUDA로 최대한의 속도 증가를
얻으려면 GPU의 메모리 구조에 대해서 잘 알아야 한다. 윈도우 한정으로 CUDA 프로그래밍의 귀찮음을 덜어 주기 위해서 만들어진
BSGP라는 녀석이 존재한다. CUDA 위에 한 층의 추상화 레이어가 더 있다고 생각하면 된다.`[3]`

CUDA 프로그램은 스트림 프로세싱`[4]`에 기반하며, 그 작성에는 [C](C%28%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%29.md)/[C++](C++.md) 언어에 동시에 실행할 쓰레드
개수 등을 선언하는데 사용되는 CUDA 전용 문법을 추가한 언어를 사용한다. CUDA 코드는 대략 GPU 안에서만 돌아가는 함수(커널이라고
부른다)를 호스트([CPU](CPU.md))에서 호출하는 형태로 되어 있다.

nVIDIA 이외의 그래픽카드에도 병렬 연산을 시키고 싶은 사람은 [OpenCL](OpenCL.md)을 사용하면 된다.`[5]`
CUDA와 문법이나 메모리 모델은 비슷한데 코딩하기는 이쪽이 좀 더 더럽다. 추상화가 덜 된 느낌.
[애플](%EC%95%A0%ED%94%8C.md), [인텔](%EC%9D%B8%ED%85%94.md),
[AMD](AMD.md)에서는 <del>[nVIDIA](nVIDIA.md)를 견제하기 위해 제대로 돌아가지도 않는</del> 이
녀석을 밀고 있다.

최근에 CUDA를 더 보완한 [OpenACC](OpenACC.md)라는 게 나왔다. 좀 더 추상화가 돼있어서 코딩하기 더 편하다고
한다. [마이크로소프트](%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%86%8C%ED%94%84%ED%8A%B8.md)에서는 [C++ AMP](C++%20AMP.md)라는 걸 만들었는데 OpenACC의 DirectCompute 버전 정도라 볼
수 있다. 그래도 아직은 일반 프로그래머가 사전지식 없이 덤빌 만한 난이도는 아니다. 단지 전에 비해 진입장벽이 많이 낮아졌을 뿐.

`\----`

  * `[1]` 연산 전용인지라 계산결과를 nVIDIA가 보증한다. 여기 들어가는 메모리는 일반적인 GDDR메모리가 아닌 오류 정정 기능이 있는 ECC메모리다. 메모리 용량 자체도 3기가 6기가 같이 매우 큰편. 다만 가격은 일반 그래픽 카드라 하기 힘들 정도로 비싸다. 비슷한 규모의 클러스터를 짜는데 드는 비용에 비하면 싸게 먹히는 편이란 점이 위안일 뿐.
  * `[2]` 범용성을 목적으로 한 CPU를 4명정도 되는 수공업자 내지는 장인으로, 단순 반복작업에 최적화된 GPU의 코어구조를 수백 명의 막노동꾼으로 비유하면 이해하기 쉽다. 이들이 각자 모여서 삽질을 시작했다고 생각해보자. 당연히 장인 4명의 삽질보다는 막노동꾼 수백 명의 삽질한 양이 더 많다.
  * `[3]` 사실 이 표현도 어폐가 있는 것이... BSGP는 CUDA의 서브셋이 아니다. CUDA의 기계어 명령번역을 사용한 별도 언어라고 보는것이 더 타당. 일례로 레이 트레이싱 류의 coherence가 낮은 작업에선 CUDA보다 성능향상이 보이지만, 반대로 메모리 참조 연속성이 강한 작업에선 CUDA보다 성능이 낮아진다.
  * `[4]` 병렬처리 프로그래밍의 일종
  * `[5]` 그러나 나온 지 기간이 꽤 되었는데도 아직 불안정하다. 애초에 일개 프로젝트로 커버하려는 범위가 너무 넓다.

