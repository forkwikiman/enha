Java Virtual Machine; JVM. [Java](Java.md)로 짠 프로그램을
[운영체제](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C.md)와 상관없이 실행하기 위해 필요한
인터프리터(해석기).

자바로 짜서 컴파일한 프로그램은 자바 바이트코드 형식으로 바뀌는데 이 자체로는 **그저
[잉여](%EC%9E%89%EC%97%AC.md).** JVM은 자바 바이트코드를 실행하는데 반드시 필요한 프로그램이다.
[에뮬레이터](%EC%97%90%EB%AE%AC%EB%A0%88%EC%9D%B4%ED%84%B0.md) 역할을 수행한다고도 할 수
있다.

에뮬레이터 답게 '롬 파일'에 해당되는 자바 바이트코드와, 자기 운영체제에 맞는 '에뮬레이터'가 있으면 어떤 운영체제에서도 똑같이 돌아간다.
그러나 에뮬레이터 답게 특정 운영 체제 전용 프로그램보다 느릴 수밖에 없다. 처음에는 바이트코드를 실행할 때 인터프리터**만** 써서
느렸으나, 개선이 되어서 이제는 그렇게 무식하게 하나 하나 해석하지 않고, JVM에서 **실행 도중에 코드를 분석하여** 알아서 CPU에
맞춘 코드를 생성, 실행하는 [Just-in-time 컴파일](JIT.md)을 구현하는 데에 이르렀다. 그래서 대부분의 경우엔 전용
프로그램과 속도가 맞먹긴 하지만, 그래도 JVM이 분석하는 시간이 조금은 필요하기 때문에, 완전히 전용 프로그램과 똑같아질 수는 없다.
다만, 자바의 경우 언어차원에서 포인터의 사용을 크게 억제하는데다가 실행하기전에 컴파일 하는 방식이기때문에 매우 공격적인 최적화가
가능하다.`[1]` 따라서, 순수 연산같은 경우에는 자바가 C/C++ 을 능가하는 퍼포먼스를 보이는 경우도 종종 나온다. 다만, 하드웨어를
직접 제어해야 하는 경우에는 제아무리 공격적인 최적화를 진행한다 해도 간단히 포인터를 허용하는편이 훨씬 강력하기때문에 상대가 안된다. 즉,
게임이나 OS 같은 영역에서는 뒤쳐질수밖에 없다.

그리고 JVM은 [가비지 컬렉션](%EC%93%B0%EB%A0%88%EA%B8%B0%20%EC%88%98%EC%A7%91.md)을
수행하여 자동으로 할당되었다가 더 안 쓰는 메모리를 회수한다. 가비지 컬렉션 작업의 특성 상 프로그램 수행을 일시 정지시켜놓고 할 수밖에
없는데`[2]`, 또 이게 자바 프로그램이 규칙적이지도 않고 이유도 없이 뚝뚝 끊긴다는 악명을 떨치는데 공헌했다. 요새는 최대한 이런 일시
정지를 줄이는 방향으로 개선되고 있다.

그래도 JVM이 가장 오래 숙성되었기 때문인지, 다른 가상 기계들은 속도나 안정성 면에서는 가볍게 압도해주고 있다. <del>[.NETFramework](.NET%20Framework.md)는 사실상 윈도 전용 가상 기계니까
논외.</del>[mono](http://www.mono-project.com/Main_Page)

[이름](%EC%9D%B4%EB%A6%84.md)에 'Java'가 들어가 있긴 해도, JVM은 **자신이 무슨 언어를 실행하는지 전혀
관심이 없다.** 형식만 올바로 지켜서 만들어졌다면 자바가 아니라 **자바 바이트코드를 만드는 다른 언어**도 얼마든지 실행할 수 있는 것.
파이썬[Jython](http://www.jython.org/)이나 루비[JRuby](http://jruby.org/) 같이 자체적인 가상
기계를 가진 언어도 JVM 위에서 돌아갈 수 있게 자바 바이트코드를 만드는 버전이 나와 있기도 하며,
[Clojure](http://clojure.org/)나 [Scala](http://www.scala-lang.org/)같은 새로운 언어들은
대놓고 JVM 위에서 돌아가는 것을 장점으로 홍보하기도 한다. JVM 위에서 돌아가는 언어들은 기존에 짜놓은 자바 라이브러리들을 쉽게 가져다
쓸 수 있으며, 기존에 자바로 구현/구축된 프로그램에 그대로 융합하여 사용할 수 있는 강점도 있다. 그래서 자바 싫어하는 사람들도 JVM까지
싸잡아 까는 경우는 흔하지 않다.

JVM은 보통 [썬 마이크로시스템즈](%EC%8D%AC%20%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%A6%88.md)에서 만든 HotSpot을 가장 많이 쓰지만, 이것만 쓸 수 있는 것은 아니다.
성능이 중요하거나 [운영체제](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C.md)가 AIX인 경우에는
[IBM](IBM.md) JDK를 사용하기도 한다. 썬에서 오픈 소스로 공개할 것을 약속하여 발표된 OpenJDK도 오픈 소스이고,
Apache Harmony와 같은 프로젝트도 있다. 다만 최근에는 [오라클](%EC%98%A4%EB%9D%BC%ED%81%B4.md)의
라이센스 정책 때문에 오픈 소스 JVM 개발이 위축되는 분위기.

[구글 안드로이드](%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%28OS%29.md) 프로그램은
자바를 사용하여 개발하지만, 안드로이드에 있는 Dalvik 가상 머신은 자바 바이트코드는 전혀 실행하지 못하므로 엄밀하게 말하면 JVM은
아니다. 다만 자바 바이트코드를 한 번 변환해서 Dalvik용 코드로 만들고 그걸 실행한다. 좀 바보같긴 하지만, JVM을 포함한 자바의
여러 부분에 걸린 특허를 피하기 위해 내놓은 꽁수. 다만 결국 썬을 인수한 오라클이 소송을 걸었다. 안드로이드가 잘 나가는 걸 본 썬은 독립
회사였을 때에 재주는 썬이 넘고 돈은 구글이 벌어서 배는 무지 아팠지만 **공돌이의 정**으로 참고 있었다고 한다. 구글이나 썬은 공돌이
회사의 대표격이었으니. 반면 오라클은 문화적으로 봤을 때 전통적인 양복 회사에 가까워서 그딴거 상관 없던 모양.

`\----`

  * `[1]` C/C++ 에서는 컴파일시 타겟 아키텍쳐를 지정해야 하기때문에 일반적인 프로그램들의 경우, 호환성을 위해 아주 옛날 하드웨어를 기준으로 컴파일 하는 경우가 많다. 이렇게 되면 그 이후 나온 새로운 명령어셋의 이점을 전혀 살릴수가 없다. 또한, 컴파일러 입장에서 어떤식으로 사용될지 예측불허인 포인터를 헤비하게 사용하기때문에, 보통 최적화 옵션을 높일수록 컴파일된 프로그램의 안정성을 보장하기 힘들어진다.(게다가 설상가상으로 어떤 부분이 어떻게 불안정해지는지 알 수도 없다.) 그리하여, 최대한 안정성을 보장해야 하는 OS 같은 경우, 아예 최적화 옵션을 가장 낮춰서 컴파일 하는 경우도 많을정도. 
  * `[2]` 일반 프로그램 입장에서는 자기가 돌아가다가 가비지 컬렉션이 분별없이 끼어들면 자기가 쓰던 메모리가 갑자기 멋대로 바뀌었다고 볼 수밖에 없다. 일반 프로그램을 안 멈춰놓고 가비지 컬렉션 작업을 하다가 순서가 꼬이기라도 하면 프로그램 오류 확정! 

